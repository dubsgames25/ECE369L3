.data
# Data section for test cases
asize0: .word 4, 4, 2, 2        # Frame and window dimensions
frame0: .word 0, 0, 1, 2        # Frame data
         .word 0, 0, 3, 4
         .word 0, 0, 0, 0
         .word 0, 0, 0, 0
window0: .word 1, 2            # Window data
         .word 3, 4

.text
.globl main
main:
    # Prologue
    addi $sp, $sp, -16           # Adjust stack pointer
    sw   $ra, 12($sp)            # Save return address
    sw   $fp, 8($sp)             # Save frame pointer
    move $fp, $sp                # Set frame pointer

    # Load test case
    la   $t0, asize0             # Load address of asize0
    lw   $t1, 0($t0)             # Load frame dimensions (4)
    lw   $t2, 4($t0)             # Load window dimensions (2)
    la   $t3, frame0             # Load address of frame0
    la   $t4, window0            # Load address of window0
    jal  FindMatch               # Find match in the test case
    # Result for the test case is now in $v0 (row) and $v1 (column)

    # Epilogue
    move $sp, $fp                # Restore stack pointer
    lw   $ra, 12($sp)            # Restore return address
    lw   $fp, 8($sp)             # Restore frame pointer
    addi $sp, $sp, 16            # Adjust stack pointer back
    jr   $ra                     # Return to caller

# Function: FindMatch
FindMatch:
    li   $t5, 0                  # Initialize row offset for the frame
loop_row:
    li   $t6, 0                  # Initialize column offset for the frame
loop_col:
    # Check if the window matches at frame[t5][t6]
    jal  MatchWindow              # Call MatchWindow
    beq  $v0, $zero, continue_col # If no match, continue checking columns

    # Match found, return indices
    move $v0, $t5                 # Save row index
    move $v1, $t6                 # Save column index
    jr   $ra                      # Return to caller

continue_col:
    addi $t6, $t6, 1              # Increment column index
    sub  $t7, $t1, $t2            # Calculate max column index
    blt  $t6, $t7, loop_col       # If column index is within limits, continue checking columns

next_row:
    addi $t5, $t5, 1              # Increment row index
    sub  $t8, $t1, $t2            # Calculate max row index
    blt  $t5, $t8, loop_row       # If row index is within limits, continue checking rows

end_find:
    li   $v0, 0                   # No match found
    jr   $ra                       # Return to caller

# Function: MatchWindow
MatchWindow:
    li   $t0, 0                   # Initialize row index for window
match_rows:
    li   $t1, 0                   # Initialize column index for window
inner_loop:
    # Calculate frame index
    mul  $t2, $t0, 4              # $t2 = row index * 4 (size of each word)
    add  $t2, $t2, $t5            # Add current frame row index offset
    mul  $t3, $t1, 4              # $t3 = column index * 4 (size of each word)
    add  $t2, $t2, $t3            # Frame index = frame base + row offset + column offset

    # Calculate window index
    la   $t4, window0             # Load address of window
    add  $t4, $t4, $t0            # Add window row index offset
    mul  $t4, $t4, 4              # Offset to window row
    add  $t4, $t4, $t1            # Add column offset for window
    lw   $t4, 0($t4)              # Load window value

    lw   $t5, 0($t2)              # Load frame value
    bne  $t4, $t5, no_match       # If values don't match, jump to no_match

    # Check next column in the window
    addi $t1, $t1, 1              # Increment window column index
    bne  $t1, $t2, inner_loop     # Continue for all columns in the window

    # Check next row in the window
    addi $t0, $t0, 1              # Increment window row index
    bne  $t0, $t2, match_rows     # Continue for all rows in the window

    li   $v0, 1                   # Match found
    jr   $ra                       # Return to caller

no_match:
    li   $v0, 0                   # No match found
    jr   $ra                       # Return to caller
