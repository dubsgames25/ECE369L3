.data
# Data section for test cases
asize0: .word 4, 4, 2, 2        # Frame and window dimensions
frame0: .word 0, 0, 1, 2        # Frame data
         .word 0, 0, 3, 4
         .word 0, 0, 0, 0
         .word 0, 0, 0, 0
window0: .word 1, 2            # Window data
         .word 3, 4

.text
.globl main
main:
    # Prologue
    addi $sp, $sp, -16           # Adjust stack pointer
    sw   $ra, 12($sp)            # Save return address
    sw   $fp, 8($sp)             # Save frame pointer
    move $fp, $sp                # Set frame pointer

    # Load test case
    la   $t0, asize0             # Load address of asize0
    lw   $t1, 0($t0)             # Load frame rows (4)
    lw   $t2, 1($t0)             # Load frame columns (4)
    lw   $t3, 2($t0)             # Load window rows (2)
    lw   $t4, 3($t0)             # Load window columns (2)
    la   $t5, frame0             # Load address of frame0
    la   $t6, window0            # Load address of window0
    jal  FindMatch                # Find match in the test case
    # Result for the test case is now in $v0 (row) and $v1 (column)

    # Epilogue
    move $sp, $fp                # Restore stack pointer
    lw   $ra, 12($sp)            # Restore return address
    lw   $fp, 8($sp)             # Restore frame pointer
    addi $sp, $sp, 16            # Adjust stack pointer back
    jr   $ra                     # Return to caller

# Function: FindMatch
FindMatch:
    li   $t7, 0                  # Initialize row offset for the frame
loop_row:
    li   $t8, 0                  # Initialize column offset for the frame
loop_col:
    # Check if the window matches at frame[t7][t8]
    jal  MatchWindow              # Call MatchWindow
    beq  $v0, $zero, continue_col # If no match, continue checking columns

    # Match found, return indices
    move $v0, $t7                 # Save row index
    move $v1, $t8                 # Save column index
    jr   $ra                      # Return to caller

continue_col:
    addi $t8, $t8, 1              # Increment column index
    sub  $t9, $t2, $t4            # Calculate maximum column index
    blt  $t8, $t9, loop_col       # If column index is within limits, continue checking columns

next_row:
    addi $t7, $t7, 1              # Increment row index
    sub  $t0, $t1, $t3            # Calculate maximum row index
    blt  $t7, $t0, loop_row       # If row index is within limits, continue checking rows

end_find:
    li   $v0, 0                   # No match found
    jr   $ra                       # Return to caller

# Function: MatchWindow
MatchWindow:
    li   $t0, 0                   # Initialize row index for window
match_rows:
    li   $t1, 0                   # Initialize column index for window
inner_loop:
    # Calculate frame index
    mul  $t2, $t7, 4              # $t2 = current frame row * 4 (size of word)
    add  $t2, $t2, $t8            # Frame index = frame row + column offset
    sll  $t2, $t2, 2               # Multiply by 4 for word offset (in bytes)

    # Calculate window index
    mul  $t3, $t0, 4              # $t3 = current window row * 4 (size of word)
    add  $t3, $t3, $t1            # Add column index
    sll  $t3, $t3, 2               # Multiply by 4 for word offset (in bytes)

    lw   $t4, frame0($t2)         # Load frame value
    lw   $t5, window0($t3)        # Load window value
    bne  $t4, $t5, no_match       # If values don't match, jump to no_match

    # Check next column in the window
    addi $t1, $t1, 1              # Increment window column index
    bne  $t1, $t4, inner_loop     # Continue for all columns in the window

    # Check next row in the window
    addi $t0, $t0, 1              # Increment window row index
    bne  $t0, $t3, match_rows     # Continue for all rows in the window

    li   $v0, 1                   # Match found
    jr   $ra                       # Return to caller

no_match:
    li   $v0, 0                   # No match found
    jr   $ra                       # Return to caller
